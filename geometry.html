<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<title>Pythagorean on a sphere</title>
		<style>
			html, body {
				margin: 0;
				height: 100%;
				overflow: hidden;
			}
			body {
				display: flex;
			}
			#scene
			{
				flex: 1;
				width: 100%;
				height: 100%;
			}
			#explanation
			{
				position: absolute;
				width: 30%;
				padding: 1em;
			}
		</style>
	</head>
	<body>
		<canvas id="scene"></canvas>
		<div id="panel">
			<table>
				<tbody>
					<tr>
						<td>alpha</td>
						<td><input id="alpha" type="number" step="0.01" value="20"/><td>
					</tr>
					<tr>
						<td>beta</td>
						<td><input id="beta" type="number" step="0.01" value="10"/><td>
					</tr>
				</tbody>
			</table>
			<button id="startButton">Start</button>
			<button id="prevButton">Previous Step</button>
			<button id="nextButton">Next Step</button>
		</div>
		<div id="explanation"/>
		<script type="importmap">
			{
				"imports":{
					"three": "https://unpkg.com/three@0.151.3/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
				}
			}
		</script>
		<script type="module">
			import * as THREE from 'three';
			import {ArcballControls} from 'three/addons/controls/ArcballControls.js';
			function animate(){
				requestAnimationFrame(animate);
				const sceneElement=document.getElementById('scene');
				const width=sceneElement.clientWidth;
				const height=sceneElement.clientHeight;
				renderer.setSize(width,height,false);
				camera.aspect=width/height;
				camera.updateProjectionMatrix();
				renderer.render(scene,camera);
			}
			const sceneElement=document.getElementById('scene');
			const scene=new THREE.Scene();
			const camera=new THREE.PerspectiveCamera(
				75,
				sceneElement.clientWidth/sceneElement.clientHeight,
				0.1,
				1000);
			const renderer=new THREE.WebGLRenderer({canvas:sceneElement});
			renderer.setClearColor(new THREE.Color(1,1,1));
			const light=new THREE.DirectionalLight(0xffffff,0.5);
			light.position.set(0,1,1);
			scene.add(light);
			scene.add(new THREE.AmbientLight(0x808080));
			camera.position.z=2;
			const controls=new ArcballControls(camera,renderer.domElement);
			controls.update();
			let step=-1;
			var alpha;
			var beta;
			var sphere;
			var leg1;
			var leg2;
			var hypotenuse;
			var orthogonalityMarker;
			var xAxis;
			var yAxis;
			var zAxis;
			var vector1;
			var vector2;
			function clearScene()
			{
				scene.remove(sphere);
				scene.remove(leg1);
				scene.remove(leg2);
				scene.remove(hypotenuse);
				scene.remove(orthogonalityMarker);
				scene.remove(xAxis);
				scene.remove(yAxis);
				scene.remove(zAxis);
				scene.remove(vector1);
				scene.remove(vector2);
			}
			function getPointOnSphere(azimuth,polar)
			{
				return new THREE.Vector3(
					Math.sin(polar)*Math.cos(azimuth),
					Math.sin(polar)*Math.sin(azimuth),
					Math.cos(polar));
			}
			function selectOrthogonalDirection(vector)
			{
				let result;
				if(Math.abs(vector[0])<Math.abs(vector[1]))
					result=new THREE.Vector3(1,0,0);
				else
					result=new THREE.Vector3(0,1,0);
				result.cross(vector);
				return result;
			}
			function createArc(startAzimuth,startPolar,finishAzimuth,finishPolar,lineColor)
			{
				let points=[
					getPointOnSphere(startAzimuth,startPolar),
					getPointOnSphere(finishAzimuth,finishPolar)];
				while(true)
				{
					let newPoints=[points[0]];
					for(let c=1;c<points.length;++c)
					{
						if(points[c-1].distanceTo(points[c])>0.05)
						{//add the middle point
							let middle=new THREE.Vector3(0,0,0);
							middle.lerpVectors(points[c-1],points[c],0.5);
							middle.normalize();
							if(middle.length()<0.5)
							{//must be a degenerate case
								middle=selectOrthogonalDirection(points[c]);
								middle.normalize();
							}
							newPoints.push(middle);
						}
						newPoints.push(points[c]);
					}
					if(newPoints.length==points.length)
						break;
					points=newPoints;
				}
				return new THREE.Line(
					new THREE.BufferGeometry().setFromPoints(points),
					new THREE.LineBasicMaterial({color:lineColor,depthFunc:THREE.AlwaysDepth}));
			}
			function createOrthogonalityMarker(markerColor)
			{
				const size=0.03;
				let points=[
					new THREE.Vector3(size,0,1),
					new THREE.Vector3(size,size,1),
					new THREE.Vector3(0,size,1)];
				return new THREE.Line(
					new THREE.BufferGeometry().setFromPoints(points),
					new THREE.LineBasicMaterial({color:markerColor,depthFunc:THREE.AlwaysDepth}));
			}
			function createTransparentSphere(radius)
			{
				let material=new THREE.MeshLambertMaterial({color:0xffffff,depthFunc:THREE.AlwaysDepth});
				material.opacity=0.5;
				material.transparent=1;
				return new THREE.Mesh(
					new THREE.SphereGeometry(radius,64,32),
					material);
			}
			function createAxis(axisIndex,axisColor)
			{
				const size=0.3;
				let points=[
					new THREE.Vector3(0,0,0),
					new THREE.Vector3(0,0,0)];
				points[1].setComponent(axisIndex,size);
				return new THREE.Line(
					new THREE.BufferGeometry().setFromPoints(points),
					new THREE.LineBasicMaterial({color:axisColor,depthFunc:THREE.AlwaysDepth}));
			}
			function createRadialVector(azimuth,polar,vectorColor)
			{
				let points=[
					new THREE.Vector3(0,0,0),
					getPointOnSphere(azimuth,polar)];
				return new THREE.Line(
					new THREE.BufferGeometry().setFromPoints(points),
					new THREE.LineBasicMaterial({color:vectorColor,depthFunc:THREE.AlwaysDepth}));
			}
			function recreateGeometry()
			{
				sphere=createTransparentSphere(0.999);
				leg1=createArc(0,0,0,alpha,0x0000ff);
				leg2=createArc(0,0,Math.PI/2,beta,0x00ff00);
				hypotenuse=createArc(0,alpha,Math.PI/2,beta,0xff0000);
				orthogonalityMarker=createOrthogonalityMarker(0x000000);
				xAxis=createAxis(0,0x0000ff);
				yAxis=createAxis(1,0x00ff00);
				zAxis=createAxis(2,0xff0000);
				vector1=createRadialVector(0,alpha,0x000000);
				vector2=createRadialVector(Math.PI/2,beta,0x000000);
			}
			function showStep()
			{
				if(step==0)
				{//problem definition
					document.getElementById("explanation").innerHTML=
						"<h4>Spherical analog of the Pythagorean theorem</h4>"+
						"<p>"+
						"We have a sphere of radius 1. Also there is a right "+
						"triangle on this sphere (its sides are arcs on the "+
						"sphere). The legs (blue and green) are known, we "+
						"need to find the hypotenuse (red)."+
						"</p>"+
						"<p>"+
						"Since we are on a unit sphere, length of an arc is "+
						"equivalent to the angle between vectors from the "+
						"centre to the arc's endpoints."+
						"</p>";
					scene.add(sphere);
					scene.add(leg1);
					scene.add(leg2);
					scene.add(hypotenuse);
					scene.add(orthogonalityMarker);
					scene.remove(xAxis);
					scene.remove(yAxis);
					scene.remove(zAxis);
					scene.remove(vector1);
					scene.remove(vector2);
				}
				else if(step==1)
				{//coordinate system
					document.getElementById("explanation").innerHTML=
						"<h4>Coordinate system</h4>"+
						"<p>"+
						"Let's introduce a coordinate system:"+
						"<p>"+
						"<ul>"+
						"<li>origin - centre of the sphere</li>"+
						"<li><font color='blue'>X</font> - the direction of the first leg at its start</li>"+
						"<li><font color='green'>Y</font> - the direction of the second leg at its start</li>"+
						"<li><font color='red'>Z</font> - from the centre to the right angle of the triangle</li>"+
						"</ul>";
					scene.add(sphere);
					scene.add(leg1);
					scene.add(leg2);
					scene.add(hypotenuse);
					scene.add(orthogonalityMarker);
					scene.add(xAxis);
					scene.add(yAxis);
					scene.add(zAxis);
					scene.remove(vector1);
					scene.remove(vector2);
				}
				else if(step==2)
				{//leg1 vector
					document.getElementById("explanation").innerHTML=
						"<h4>First leg endpoint vector coordinates</h4>"+
						"<p>"+
						"In this coordinate system the vector from the "+
						"sphere centre to the endpoint of the first leg "+
						"will have the following coordinates:"+
						"<p>"+
						"<ul>"+
						"<li>X=sin(alpha)</li>"+
						"<li>Y=0</li>"+
						"<li>Z=cos(alpha)</li>"+
						"</ul>";
					scene.add(sphere);
					scene.add(leg1);
					scene.add(leg2);
					scene.add(hypotenuse);
					scene.add(orthogonalityMarker);
					scene.add(xAxis);
					scene.add(yAxis);
					scene.add(zAxis);
					scene.add(vector1);
					scene.remove(vector2);
				}
				else if(step==3)
				{//leg2 vector
					document.getElementById("explanation").innerHTML=
						"<h4>Second leg endpoint vector coordinates</h4>"+
						"<p>"+
						"For the second leg the vector will have the "+
						"following coordinates:"+
						"<p>"+
						"<ul>"+
						"<li>X=0</li>"+
						"<li>Y=sin(beta)</li>"+
						"<li>Z=cos(alpha)</li>"+
						"</ul>";
					scene.add(sphere);
					scene.add(leg1);
					scene.add(leg2);
					scene.add(hypotenuse);
					scene.add(orthogonalityMarker);
					scene.add(xAxis);
					scene.add(yAxis);
					scene.add(zAxis);
					scene.add(vector1);
					scene.add(vector2);
				}
				document.getElementById("prevButton").disabled=(step<=0);
				document.getElementById("nextButton").disabled=(step>=3);
			}
			document.getElementById("startButton").onclick=function()
			{
				clearScene();
				alpha=Number(document.getElementById("alpha").value)*Math.PI/180;
				beta=Number(document.getElementById("beta").value)*Math.PI/180;
				recreateGeometry();
				step=0;
				showStep();
			};
			document.getElementById("prevButton").onclick=function()
			{
				--step;
				showStep();
			};
			document.getElementById("nextButton").onclick=function()
			{
				++step;
				showStep();
			};
			document.getElementById("prevButton").disabled=true;
			document.getElementById("nextButton").disabled=true;
			animate();
		</script>
	</body>
</html>
